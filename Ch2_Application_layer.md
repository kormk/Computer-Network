# 2. Application layer

## 네트워크 애플리케이션의 원리
## 2.1.1 네트워크 애플리케이션 구조

### 클라이언트-서버 구조
- 항상 동작하고 있는 호스트를 서버(server)라고 부르며, 서버와의 서비스는 클라이언트(client)라는 다른 호스트들로부터 서비스 요청을 받는다.
- 클라이언트는 가끔 또는 항상 켜져 있을 수 있다.
- **클라이언트는 서로 직접 통신하지 않는다.**
    >예시. 웹 애플리케이션  
웹 서버가 클라이언트 호스트로부터 객체를 요청받으면 웹서버는 요청된 객체를 클라이언트 호스트로부터 객체를 요청받으면서 응답한다.
- **서버가 고정 IP 주소라는 잘 알려진 주소를 갖는다.**


- 하나의 클라이언트-서버 애플리케이션에서 하나의 서버 호스트가 자신의 클라이언트로부터 오는 모든 요청을 다 응답하는 것은 불가능하다. 이러한 이유로 많은 수의 호스트를 갖춘 **데이터 센터(data center)** 가 강력한 가상의 서버를 생성하는 역할로 사용된다.
  > 서비스 제공자들은 데이터 센터로부터 데이터를 보내기 위해 상호 연결과 대역폭에 합당한 비용을 지불해야한다.

### P2P  구조
- 항상 켜져 있는 인프라스트럭쳐 서버에 최초로 의존한다. 대신 애플리케이션은 피어(peer)라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하게 한다.
- **자가 확장성(self-scalability)**
  > P2P 파일공유 애플리케이션에서는 각 피어들이 파일을 요구함으로써 작업 부하를 만들어낸다. 하지만 각 피어들은 파일을 다른 피어들에게 분배함으로써 그 시스템에 서비스 능력을 추가한다.
- 비용 효율적
  > 서버 인프라스트럭쳐와 서버 대역폭을 요구하지 않기 때문이다.


## 2.1.2 프로세스간 통신
실제 통신하는 것은 프로그램이 아니라 프로세스(process)이다.
프로세스 간의 통신을 위한 규칙은 종단 시스템의 운영체제에 의해 좌우된다.

### 클라이언트와 서버 프로세스
- in web
  - 웹 브라우저: 클라이언트
  - 웹 서버: 서버

- P2P
  - 파일 다운로드 피어: 클라이언트
  - 파일 업로드 피어: 서버

- 클라이언트와 서버 프로세스에 대한 정의
    ~~~
    두 프로세스 간의 통신 세션에서 통신을 초기화하는 프로세스를 클라이언트라 하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.
    ~~~

### 프로세스와 컴퓨터 네트워크 사이의 인터페이스
- 프로세스는 소켓을 통해 네트워크로 메세지를 보내고 받는다.
- 소켓은 호스트의 애플리케이션 계층과 트랜스포트 게층 간의 인터페이스다.(애플리케이션과 네트워크 사이의 API)
- 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다.(프로토콜 선택, 최대 버퍼 등의 매개변수 설정뿐)

### 프로세스 주소 배정
한 호스트 상에서 수행되고있는 프로세스가 패킷을 다른 호스트에서 수행되고 있는 프로세스로 패킷을 보내기 위해서는 수신 프로세스가 주소를 갖고 있어야 한다.

수신 프로세스를 식별하기 위해서는 다음의 두 가지 정보가 명시되어야 한다.
- 호스트의 주소(IP)
- 목적지 호스트 내의 수신 프로세스를 명시하는 식별자(Port number)

IP주소는 32비트로 구성되며, 호스트를 유일하게 식별한다.

메세지가 전달되어야 하는 호스트의 주소를 아는 것과 더불어 송신 호스트는 수신 호스트에서 수행되고 있는 수신 프로세스(수신 소켓)도 식별 해야한다.
~~~
목적지 포트 번호(port number)가 수신 호스트에서 수행되고 있는 수신 프로세스(수신 소켓) 식별을 위해 사용된다.
~~~



## 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
- 인터넷을 포함해서 많은 네트워크는 하나이상의 트랜스포트 프로토콜을 제공한다.  
- 트랜스포트 계층 프로토콜이 애플리케이션들에게 제공할 수 있는 서비스
  - 신뢰적 데이터 전송
  - 처리율
  - 시간
  - 보안


### 신뢰적 데이터 전송
- 만약 프로토콜이 보장된 데이터 전송 서비스를 제공한다면 이를 **신뢰적 데이터 전송(reliable data transfer)** 을 제공한다고 한다.  

- 트랜스포트 프로토콜이 이 서비스를 제공할 때 송신 프로세스 는 데이터를 소켓으로 보내고 그 데이터가 오류없이 수신 프로세스에 도착할 것이라는 확신을 갖는다.  

- 트랜스포트 계층 프로토콜이 신뢰적 데이터 전송을 제공하지 않을 때, 송신 프로세스가 보낸 데이터는 수신 프로세스에 전혀 도착하지 않을 수 있다. 이것은 **손실 허용 애플리케이션(loss-tolerant application)** 으로 비디오/오디오 같은 멀티미디어 애플리케이션에서 받아들여질 수 있다.
  

### 처리율
네트워크 경로를 따라 두 프로세스간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율을 나타낸다.


이 세션들이 생겼다 없어졌다 하기 때문에 가용 처리율은 시간에 따라 변동한다.

이러한 관찰로 트랜스포트 프로토콜이 제공할 수 있는 다른 자연적인 서비스, 
~~~
명시된 속도에서 보장된 가용 처리율을 제공한다.
애플리케이션은 r bit/sec의 보장된 처리율을 요구할 수 있고 트랜스포트 프로토콜은 가용한 처리율이 항상 적어도 r bps임을 보장한다
~~~

- 대역폭 민감 애플리케이션(bandwidth-seneitive application): 처리율 요구사항을 갖고있다.
- 탄력적 애플리케이션(elastic application)

### 시간
트랜스포트 계층은 시간보장(time guarantee)을 제공할 수 있다.(모든 비트가 수신자의 소켓이 일정 시간 내에 도착하는 것)

### 보안
트랜스포트 프로토콜은 애플리케이션에 하나이상의 보안서비스를 제공할 수 있다.
- confidentiality
- integrity
- authentication
  

## 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

### TCP
- 연결지향형 서비스
  - 핸드셰이킹(전송 제어 정보 교환)과정이 클라이언트와 서버에 패킷이 곧 도달할 테니 준비하라고 알림
  - TCP연결이 두 프로세스의 소켓 사이에 존재한다고 말한다.
  - 애플리케이션이 메세지 전송을 마치면 연결을 끊어야한다.

- 신뢰적인 데이터 전송서비스: 통신 프로세스는 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다.
- 혼잡제어: 프로세스의 직접적인이득 보다 인터넷 전체의 성능향상을 위한 서비스를 포함


### UDP
- 비연결형 이므로 핸드셰이킹을 하지않는다.
- 메세지가 수신소켓에 도착하는 것을 보장하지 않는다.
- 메세지들의 순서가 뒤바뀔 수도 있다.
- 혼잡 제어 방식을 포함하지 않는다.
>따라서 UDP의 송신 측은 데이터를 원하는 속도로 하위(네트워크) 계층으로 보낼 수 있다.
## 2.1.5 애플리케이션 계층 프로토콜
애플리케이션 계층 프로토콜은 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 다른 메시지를 보내는 방법을 정의한다.
~~~
1. 교환 메시지 타입
2. 여러 메시지 타입의 문법
3. 필드의 의미, 즉 필드에 있는 정보의 의미
4. 언제, 어떻게 프로세스가 메시지르 전송하고 메시지에 응답하는지 결정하는 규칙
~~~


네트워크 애플리케이션과 애플리케이션 계층 프로토콜의 구분
- 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 요소일 뿐
- 웹은 사용자가 필요에 따라 웹서버로 부터 문서를 얻게 해주는 네트워크 애플리케이션이다.

## 2.2 웹과 HTTP

### 2.2.1 HTTP개요
웹의 애플리케이션 계층 프로토콜인 HTTP는 웹의 중심이다. HTTP는 두 가지 프로그램으로 구현된다(클라이언트 프로그램과 서버 프로그램).  
 각기 다른 종단시스템에서 수행되는 클라이언트 프로그램과 서버 프로그램은서로 HTTP 메시지를 교환하여 통신한다.  
 HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의하고있다. 

 웹페이지는 기본 HTML파일과 여러 참조 객체로 구성된다.  
 객체는 단순히 URL로 지정할 수 있는 하나의 파일(HTML파일, JPEG 이미지, 자바스크립트 등)이다.  
 기본 HTML파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다.
 URL은 객체를 갖고 있는 서버의 호스트 이름과 객체의 경로 이름을 갖고 있는다.


 HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다.
 ~~~
HTTP는 TCP를 전송 프로토콜로 사용한다.
HTTP클라이언트는 먼저 서버에 TCP연결을 시작한다.
(연결이 이루어지면)브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다.
클라이언트는 HTTP요청 메시지를 소켓 인터페이스로 보내고 소켓인터페이스로부터 HTTP 응답 메시지를 받는다. 마찬가지로 HTTP서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.
클라이언트가 메시지를 소켓 인터페이스로 보내면 메시지는 클라이언트의 손을 떠나 TCP의 손에 쥐어진 것이다. TCP는 신뢰적인 데이터 전송을 하기 때문에 HTTP요청 메시지가 서버에 도착한다는 것을 보장한다.
 ~~~
  
 HTTP는 비상태 프로토콜이다 (stateless protocol)
 > 서버가 클라이언트에게 요청 파일을 보낼 때 서버는 클라이언트에 관한 어떠한 상태 정보도 저장하지 않는다.


### 2.2.2 비지속 연결과 지속 연결

요구/응답 쌍이 분리된 TCP연결을 통해 보내져야 하는가? -> 비지속 연결  
모든 요구와 해당하는 응답들이 같은 TCP연결 상으로 보내져야 하는가? -> 지속 연결

### 비지속 연결 HTTP  
연결 수행과정
~~~
가정.
페이지가 기본HTML파일과 10개의 JPEG이미지로 구성되고, 이 11개의 객체가 같은서버에 있다.
기본 HTML파일의 URL은 다음과 같다.
http://www.someSchool.edu/someDepartment/home.index
~~~
~~~
1. HTTP 클라이언트는 HTTP의 기본 포트번호 80을 통해 www.someSchool.edu 서버로 TCP 연결을 시도한다.
TCP연결과 관령하여 클라이언트와 서버에 각각 소켓이 있게된다.
~~~
~~~
2.HTTP클라이언트는 1단계에서 설정된 TCP연결 소켓을 통해 서버로 HTTP요청 메시지를 보낸다.
이 요청 메시지는 /someDepatment/home.index 경로 이름을 포함한다.
~~~
~~~
3. HTTP서버는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다. 
저장장치로부터 /someDepartment/home.index 객체를 추출한다. 
HTTP응답 메시지에 그 객체를 캡슐화한다. 
그리고 응답 메시지를 소켓을 통해 클라이언트로 보낸다.
~~~
~~~
4. HTTP 서버는 TCP에게 TCP연결을 끊으라고 한다.(클라이언트가 응답 메시지를 올바로 받을 때까지는 연결을 유지)
~~~
~~~
5.HTTP 클라이언트가 응답 메시지를 받으면 TCP연결이 중단된다.메시지는 캡슐화된 객체가 HTML파일인 것을 나타낸다. 
클라이언트는 응답 메시지로부터 파일을 추출하고 HTML파일을 조사하고 10개의 JPEG객체에 대한 참조를 찾는다.
~~~
~~~
6. 그 이후 참조되는 각 JPEG객체에 대해 처음 네 단계를 반복한다.
~~~
~~~
고찰.
HTTP/1.0은 비지속 연결을 지원한다. 각 TCP연결은 하나의 요청메시지와 하나의 응답 메시지만 전송한다. 
그래서 이 에에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP연결이 만들어진다.
브라우저는 다중 TCP연결을 설정하여 응답시간을 줄일 수도 있다.

단점.
1. 각 요청에 객체에 대한 새로운 연결이 설정되고 유지되어야한다. TCP버퍼가 할당되어야 하고 TCP변수들이 클라이언트와 서버 양쪽에 유지되어야 한다.이는 웹 서버에게 심각한 부담을 줄 수있다.

2. 각 객체는 2RTT를 필요로 한다.
(TCP연결에서 1RTT, 객체를 요청하고 받는데 1RTT)
~~~

### 지속연결 HTTP
HTTP/1.1 지속연결에서 서버는 응답을 보낸 후에 TCP연결을 유지한다. 같은 클라이언트와 서버간의 이후 요청과 응답은 같은 연결을 통해 보내진다.  
객체에 대한 요구는 진행중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수있다.(파이프라이닝)  
일반적으로 HTTP서버는 일정기간 사용되지 않으면 연결을 닫는다. 서버가 연속된 요구를 수신할 때 서버는 객체를 연속해서 보낸다.


### 2.2.3 HTTP 포멧
