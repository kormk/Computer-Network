# 트랜스포트 계층
## 3.1 트랜스포트 계층 서비스 및 개요
트랜스포트 계층 프로토콜은 각 다른 호스트에서 동작하는 애플리케이션 프로세스간의 논리적 통신을 제공한다.

네트워크 라우터는 오로지 데이터그램의 네트워크 계층필드에 대해 동작한다.
## 3.1.1 트랜스포트 계층과 네트워크 계층사이의 관계
프랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 프로세스들 사이의 논리적 통신을 제공하지만 네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신을 제공한다.

## 3.1.2 인터넷 트랜스포트 계층의 개요
인터넷의 네트워크 계층 프로토콜은 인터넷 프로토콜(Internet Protocol: IP)이라는 이름을 갖는다.

IP서비스 모델은 호스트들 간에 논리적 통신을 제공하는 최선형 전달서비스다. 이것은 이것은 IP가 통신하는 호스트들 간에 세그먼트를 전달하기 위해 최대한 노력하지만 어떠한 보장도 하지 않는 다는 것을 의미한다. 세그먼트 전달을 보장하지 않고 세그먼트가 순서대로 전달되는 것을 보장하지 않는다.

이러한 이유로 IP를 비신뢰적인 서비스라고 부른다.


UDP와 TCP의 서비스 모델


UDP와 TCP의 기본적인 기능은 종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다.

> host-to-host를 proc-to-proc로 확장하는 것을 **트랜스포트 계층 다중화** 혹은 **역다중화**라고 부른다.

UDP가 제공하는 서비스
1. 헤더에 오류 검출필드를 포함 함으로써 무결성 검사를 제공한다.
2. host-to-host를 proc-to-proc로 확장


TCP가 제공하는 서비스
1. 헤더에 오류 검출필드를 포함 함으로써 무결성 검사를 제공한다.
2. host-to-host를 proc-to-proc로 확장
3. 신뢰적인 데이터 전송
4. 혼잡제어

~~~
TCP는 IP의 비신뢰적인 서비스를 프로세스 사이의 신뢰적인 데이터 전송 서비스로 만들어준다.

혼잡제어는 한 TCP연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 혼잡하게 하는 것을 방지하는 것이 TCP혼잡 제어이다.
(송신측의 트래픽조절)
~~~

## 3.2 다중화와 역다중화
호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않는다. 대신에 중간 매개자인 소켓에게 전달한다. 어떤 주어진 시간에 수신 측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 하나의 유일한 식별자를 갖는다.(이 식별자는 TCP 소켓인지 UDP소켓인지에 따라 달라진다.)

수신측의 트랜스포트 계층은 수신 소켓을 식별하기위해 이러한 필드를 검사한다. 그리고 이 세그먼트를 해당 소켓으로 보낸다.

> 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 **역다중화** 라고 한다.

>출발지 호스트 소켓으로부터 데이터를 모으고,이에 대한 
>세그먼트를 생성하기 위해 각 데이터에 헤더정보로 캡슐화하고,
>그 세그먼트들을 네트워크 계층으로 전달하는 작업을 **다중화**라고한다.

> 다중화와 역다중화는 한 계층에서의 한 프로토콜이 그 상위계층의 여러 프로토콜에 의해 사용될 때마다 관련된 것이다. (다중화와 역다중화는 트랜스포트 계층에서만 일어나는 것이 아니다.)


### 트랜스포트 계층 다중화와 역다중화의 수행과정(UDP)

### 다중화

트랜스포트 다중화에는 다음 두 가지 요구사항이 있음을 알 수있다.
1. 소켓은 유일한 식별자를 갖는다.
2. 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다.
>특별한 필드에는 출발지 포트 번호 필드, 목적지 포트 번호 필드가 포함된다.
각각의 포트 번호는 0~65535까지의 16비트 정수이다. 그 중 0~1023까지의 포트번호는 well-known prot number라고 하며 사용을 엄격하게 제한한다.
또한 TCP세그먼트는 이 밖의 필드도 가진다.


### 역다중화

호스트의 각 소켓은 포트번호를 할당받는다. 그리고 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세그먼트 안의 목적지 번호필드를 검사하고 상응하는 소켓으로 세그먼트를 보내게 된다. 그러면 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다.

### 트랜스포트 계층 다중화와 역다중화의 수행과정(TCP)
TCP 역다중화를 수행하기 위해서는 TCP소켓과 TCP연결설정을 살펴봐야한다. TCP소켓과 UDP소켓의 다른점은 TCP소켓은 4개의 요소의 집합(four tuple), 즉 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별된다는 것이다. 


웹 서버와 TCP

프로세스는 각자 연결 소켓을 가지며, 이 연결 소켓을 통해 HTTP요청을 수신하고, HTTP응답을 전송한다. 그러나 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것은 아니다.

오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다. 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드를 생성한다.

## 3.3 비연결형 트랜스포트: UDP
적어도 트랜스포트 계층은 네트워크 계층과 해당하는 애플리케이션 레벨 프로세스 간의 데이터를 넘겨주기 위해 다중화와 역다중화를 제공해야한다.

[RFC 758]에서 정의된 UDP는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다. UDP는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.(애플리케이션 개발자가 TCP대신 UDP를 선택하면 애플리케이션은 IP와 직접 통신하는 셈이다.)

UDP는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 핸드셰이크를 사용하지 않는다. 이러한 이유로 UDP를 비연결형이라고 한다.



많은 애플리케이션에 UDP가 선호되는 이유

- 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어  
  ~~~
  UDP하에서 애플리케이션 프로세스가 데이터를 UDP에게 전달하자마자 UDP는 데이터를 UDP세그먼트로 만들고, 그 세그먼트를 즉시 네트워크 계층으로 전달한다.
  이에 반해 TCP는 하나 이상의 통신 링크가 혼잡상태이면 TCP송신자를 제한하며, 세그먼트의 수신 여부가 확인 응답될 때 까지 데이터 세그먼트를 계속해서 전송한다.
  ~~~
- 연결 설정이 없음
  ~~~
  TCP는 데이터 전송을 시작하기 전에 세 방향 핸드셰이크를 사용한다. 하지만 UDP는 공식적인 사전준비 없이 전송한다. 그러므로 UDP는 연결을 설정하기 위한 어떤 지연도 없다.(DNS가 UDP에서 동작하는 이유)
  ~~~
  
- 연결 상태가 없음
  ~~~
  TCP는 종단 시스템에서 연결상태를 유지한다. 이 연결상태는 수신 버퍼와 송신 버퍼, 혼잡제어 파라미터, 순서번호와 확인 응답 번호파라미터를 포함한다. 이 상태정보가 신뢰적 데이터 전송 서비스를 구현하고 혼잡제어 서비스를 제공하는데 필요하다.
  이에 반해 UDP는 연결상태를 유지하지 않으며 이 파라미터 중 어떤것도 기록하지 않는다.
  ~~~
- 작은 패킷 오버헤드
  ~~~
  TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 가진다.
  UDP는 8바이트의 헤더 오버헤드를 가진다.
  ~~~



UDP의 혼잡제어 결여는 UDP송신자와 수신자 간의 높은 손실율을 초래할 수도 있고 TCP세션의 혼잡이 발생할 수 있으며 이는 잠재적으로 심각한 문제이다. 
애플리케이션이 UDP를 사용할 때도 신뢰적인 데이터 전송이 가능하다. 이 과정은 개발자에 의해 오랜시간 디버깅 하는 어려운 작업이며 이로 인해 애플리케이션 프로세스들은 TCP의 혼잡 제어 메커니즘에 의해 전송률 억제를 강요당하지 않고도 신뢰적인 통신을 할 수 있다.

### 3.3.1 UDP세그먼트 구조
UDP헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다.
- 출발지 포트번호
- 목적지 포트번호
- 체크섬: 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용한다.
- 길이: 헤더를 포함하는 UDP세그먼트의 길이를 나타낸다.
- 애플리케이션 데이터(DNS에서는 질의메세지, 응답 메세지등을 포함, 스트리밍 오디오 애플리케이션에서는 오디오 샘플이 데이터 필드를 채운다.)



체크섬: 만약 패킷에 어떤 오류도 없다면 수신자의 합은 모든 비트가 1이다. 


#### 링크 프로토콜이 오류검사를 제공하는데 UDP가 체크섬을 제공하는 이유
  
출발지와 목적지 사이의 모든 링크가 오류검사를 제공한다는 보장이 없기 때문이다.
주어진 링크간의 신뢰성과 메모리의 오류 검사가 보장되지 않고, 종단 간의 데이터 전송 서비스가 오류검사를 제공해야한다면 UDP는 종단기반으로 트랜스포트 계층에서 오류를 제공해야만 한다. 이것이 **종단과 종단의 원칙**의 한 예이다.
즉 어떤기능이 종단기반으로 구현되어야 하므로 하위레벨에 있는 기능들은 상위레벨에서 이들을 제공하는 비용과 비교했을 때 중복되거나 거의 가치가 없을 수 있다는 것이다.

또한 UDP는 오류검사를 제공하지만 오류를 회복하기 위한 어떤 일도 하지 않는다.


# 3.4 신뢰적 데이터전송
신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지않는다. 그리고 모든 데이터가 전송된 순서 그대로 전달된다. 이것이 TCP가 인터넷 애플리케이션에 제공하는 서비스 모델이다.



~~~
전이를 발생시키는 이벤트는 변화를 표기하는 가로선 위에 나타낸다.
이벤트가 발생했을 때 취해지는 액션은 가로선아래
이벤트 발생 시 어떠한 행동도 취해지지 않거나 어떠한 이벤트발생없이 행동이 취해질 때 동작이나 이벤트가 없음을 나타낼 때 람다 기호(Λ)를 사용
FSM의 초기상태는 점선으로 나타낸다
~~~

## rdt 1.0: 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터전송

- 송신측  
  ~~~
  상위로부터 호출을 기다림  
  rdt_send(data): 해당 이벤트에 의해 상위 계층으로부터 데이터를 받아들이고  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  packet=make_pkt(data): 데이터를 포함한 패킷을 생성한다.  
  udt_send(packet): 채널로 송신.
  ~~~

  > rdt_send이벤트는 상위 애플리케이션계층 애플리케이션의 프로시저 호출에 의해 발생한다.


- 수신측  
  ~~~
  rdt_rcv(packet): 해당 이벤트에 의해 하위채널로 부터 패킷을 수신  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  extract(packet, data): 데이터를 추출 한 후   
  deliver_data(data): 데이터를 상위 계층으로 전달  
  ~~~

## rdt2.0: 비트오류가 있는 채널상에서의 신뢰적인 데이터 전송
### stop-and-wait protocol

>패킷안의 비트들이 하위 채널에서 손상되는 모델 (비트 오류는 전송 또는 전파되거나 버퍼링 될 때 네트워크의 물리적 구성요소에서 일반적으로 발생한다.)전송된 모든 패킷이 송신된 순서대로 수신된다고 가정

긍정 확인응답, 부정 확인응답을 둘 다 사용한다. 이러한 제어메세지는 정확하게 수신되었는지 또는 잘못 수신되어 반복이 필요한지를 수신자가 송신자에게 알려줄 수 있게 한다. 컴퓨터 네트워크 설정에서 그러한 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 자동 재전송 요구 프로토콜(ARQ)로 알려져있다.


ARQ프로토콜에 요구되는 세가지 부가기능
1. 오류검출: 비트오류가 발생했을 때 수신자가 검출할 수 있는기능이 필요하다.(체크섬)
2. 수신자 피드백: 수신자가 송신자에게 긍정 확인응답, 부정 확인응답을 보낸다.
3. 재전송


- 송신측
  ~~~
  rdt_send(data)  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  sndpkt=make_pkt(data, chaecksum)
  udt_send(sndpkt)
  ~~~
  ~~~
  rdt_rcv(rcvpkt)&&isNAK(rcvpkt)  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  udt_send(sndpkt)
  ~~~
  ~~~
  rdt_rcv(rcvpkt)&&isACK  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  Λ
  ~~~

송신자가 ACK 또는 NAK를 기다리는 상태에 있을 때 상위 게층으로 부터 더 이상의 데이터를 전달받을 수 없다.(rdt_send()이벤트는 발생할 수 없다.)  
그러므로 송신자는 수신자가 정확하게 수신했음을 확신하기 전까지 새로운 데이터를 전달하지 않을것이다. 이런 행동때문에 rdt2.0은 stop-and-wait 프로토콜로  알려져 있다.


- 수신측
  ~~~
  rdt_rcv_(rcvpkt)&&corrupt(rcvpkt)  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  sndpkt=makepkt(NAK)  
  ud_send(sndpkt)  
  ~~~

  ~~~
  rdt_rcv(rcvpkt)&&notcorrupt(rcvpkt)  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
  extract(rcvpkt,data)  
  deliver_data(data)  
  sndpkt=make_pkt(ACK)  
  udt_send(sndpkt)
  ~~~


수신자 측FSM은 단일 상태를 갖는다. 패킷이 도착했을 때, 수신자는 수신된 패킷이 손상되었는지 아닌지에 따라 ACK혹은 NAK으로 응답한다.



문제점: ACK, NAK패킷의 손상 가능성을 고려하지 않음

손상된 ACK, NAK를 처리하기 위한 3가지 시나리오
1. 수신자의 NAK가 계속해서 손실 될 경우 송신자는 수신자가 어떤 요청을 보내오는지 알수 없으므로 문제가 어려워진다.
2. 비트 오류를 검출할 수 있도록 충분한 체크섬 비트들을 추가하는 것. 이 방식은 패킷은 손상될 수 있으나 손실되지는 않는 채널의 경우에는 즉각적으로 문제를 해결할 수 있다.
3. 송신자가 왜곡된 ACK 또는 NAK패킷을 수신할 때 현재 데이터 패킷을 단순히 송신하는 것이다. 중복 패킷의 가장 근본적을 어려운 점은 마지막으로 전송된 ACK또는 NAK가 송신자에게 정확하게 수신됐는지를 알 수 없다는 것이다. 그러무로 도착하는 패킷이 새로운 데이터를 포함하는 것인지 아니면 재전송인지 사전에 알 수 없다.





## rdt2.1: 데이터 패킷에 새로운 필드를 추가하고 이 필드에 순서번호를 삽입하는 방식


수신자는 수신된 패킷이 재전송인지를 결정할 때는 이 순서 번호만 확인하면 된다.
(간단한 stop-and-wait의 경우 mod 2 연산을 통해 재전송 패킷인지 새로운 패킷인지 구분한다.)


rdt2.1 송신자

상위로부터 0번 호출을 기다림
~~~
rdt_send(data)  
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
sndpkt=make_pkt(0,data,checksum)
udt_send(sndpkt)
~~~


0에 대한 응답을 기다림 

~~~
(현 상태로 복귀)
rdt_rcv(rcvpkt&&(corrupt(rcvpkt)||isNAK(rcvpkt)))
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
udt_send(sndpkt)
~~~
~~~
(상태 전이)
rdt_rcv(rcvpkt&&notcorrupt(rcvpkt)&&isACK(rcvpkt))
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
Λ
~~~

상위로부터 1번 호출을 기다림
~~~
rdt_send(data)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
sndpkt = make_pkt(1,data,checksum)
udt_send(sndpkt)
~~~

1에 대한 ACK또는 NAK응답을 기다림
~~~
(현 상태로 복귀)
rdt_rcv(rcvpkt)&&(corrupt(rcvpkt)||isNAK(rcvpkt))
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
udt_send(sndpkt)
~~~

~~~
(상태 전이)
rdt_rcv(rcvpkt)&&notcorrupt(rcvpkt)&&isACK(rcvpkt)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
Λ
~~~

rdt2.1 수신자


하위로 부터 0번 호출을 기다림
~~~
(현 상태로 복귀)
rdt_rcv(rcvpkt)&&corrup(rcvpkt)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
sndpkt=make_pkt(NAK,checksum)
udt_send(sndpkt)
~~~

~~~
(현 상태로 복귀)
rdt_rcv(rcvpkt)&&corrupt(rcvpkt)&&has_seq1(rcvpkt)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
sndpkt=make_pkt(ACK,checksum)
udt_send(sndpkt)
~~~

~~~
(상태 전이)
rdt_rcv(rcvpkt)&&notcorrupt(rcvpkt)&&hash_seq0(rcvpkt)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
extract(rcvpkt,data)
deliver_data(data)
sndpkt=make_pkt(ACK,checksum)
udt_send(sndpkt)
~~~


하위로부터 1번 호출을 기다림
~~~
(현 상태로 복귀)
rdt_rcv(rcvpkt)&&corrup(rcvpkt)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
sndpkt=makepkt(NAK,checksum)
udt_send(sndpkt)
~~~








## rdt3.0: 비트오류와 손실있는 채널상에서의 신뢰적인 데이터전송







## 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

## 3.4.3 GBN
GBN(GoBack N, N부터 반복)프로토콜에서 송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송할 수있다. 그러나 파이프라인에서 확인응답이 안된 패킷의 최대 허용 N보다 크지 말아야한다.


base: 확인 응답이 안 된 가장 오래된 패킷의 순서번호를
nextseqnum: 다음에 전송될 패킷의 순서
N: 윈도 크기


순서 범위에서 4개의 간격을 식별할 수 있다.
1. [ 0, base-1 ] : 이미 전송되고 확인응답이 된 패킷에 대응 
2. [ base, nextseqnum -1 ] : 송신되었지만 아직 확인응답되지 않은 패킷에 대응된다.
3. [ nextseqnum, base+N-1 ] : 상위 계층으로부터 데이터가 데이터가 도착하면 바로 전송될 수 있는 패킷을 위해 사용될 수 있다.
4. [ base+N 이상 ] : 파이프라인에서 확인응답이 안된 패킷



GBN프로토콜은 슬라이딩 윈도 프로토콜이다.

확인 안된 패킷의 수를 N으로 제한하는 이유?



실제로 패킷의 순서 번호는 패킷 헤더 안의 고정된 길이 필드에 포함된다. 만약 k가 패킷 순서 번호 필드의 비트 수라면, 순서 번호의 범위는 [ 0, 2^k-1 ]이 된다.(순서 번호의 제한된 범위에서, 순서번호를 포함하는 모든 계산은 mod 2^k 연산을 이용한다.)

>여기서의 순서번호는 TCP에서의 순서번호와 다른 것이다.(TCP에서의 순서번호는 바이트 스트림에서 바이트를 세는 수)

GBN송신자는 다음과 같은 세 가지 타입의 이벤트에 반응해야한다.

1. 상위로부터의 호출
   ~~~
   rdt_send()가 위로부터 호출되면, 송신자는 우선 윈도가 가득 찼는지, 즉 N개의 아직 확인응답되지 않은 패킷이 있는지 확인한다.
   : 가득 차 있지않다면 패킷이 생성되고 송신된다.
   : 가득 차 있다면, 송신자는 윈도가 가득 차 있음을 가리키는 함축적인 의미로 단지 데이터를 상위계층으로 반환한다.상위 계층은 나중에 다시 시도할 것이다. 

   실제적인 구현에서 송신자는 이 데이터를 버퍼링하거나, 오직 윈도가 가득 차 있지 않을 때만 rdt_send()를 호출하는 동기화 메커니즘을 사용할 것이다.
   ~~~

2. ACK의 수신
   ~~~
   GBN 프로토콜에서 순서 번호 n을 가진 패킷에 대한 확인응답은 누적확인  응답으로 인식된다. 이 누적 확인응답은 수신측에서 올바르게 수신된 n을  포함하여, n까지의 순서번호를 가진 모든 패킷에 대한 확인응답이다. 
   ~~~

3. 타임아웃 이벤트
   ~~~
   타이머는 손실된 데이터 또는 손실된 확인 응답 패킷으로부터 회복하는 데 사용된다. 만약 타임아웃이 발생한다면, 송신자는 이전에 전송되었지만 아직 확인응답이 되지 않은 모든 패킷을 다시 송신한다.한 ACK가 수신되고 추가로 송신했지만 확인 안된 패킷이 존재한다면 타이머는 다시 시작된다.
   ~~~



GBN에서 수신자의 행동도 단순하다. 만약 순서 번호n을 가진 패킷이 오류 없이 순서대로 수신된다면 수신자는 패킷 n에 대한 ACK를 송신하고 상위계층에 패킷의 데이터 부분을 전달한다. 그 외의 경우에는 수신자는 그 패킷을 버리고 가장 최근에 제대로 수신된 순서의 패킷에 대한 ACK를 재전송한다. 

만약 패킷 k가 수시되고 상위계층에 전달되었다면 k보다 낮은 순서 번호를 가진 모든 패킷 또한 전달되어 있다는 것을 유념해야한다.


GBN 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다.
데이터는 상위계층에게 순서대로 전달되어야 하므로 패킷 n번보다 n+1번이 먼저 도착한 경우 이후에 n번 패킷이 도착하고 상위계층으로 전달 된 이후에 n+1번 패킷이 전달된다. 하지만 n번패킷이 손실 된 경우 n번과 n+1번 모두 재전송된다.


이러한 접근의 이점은 수신자 버퍼링이 간단하다는 것이다. 수신자는 어떤 순서가 잘못된 패킷에 대해 버퍼링을 할 필요가 없다 그러므로 송신자는 윈도 상위와 하위 경계와 이 윈도안에 있는 nextseqnum 위치를 유지해야 하지만 수신자가 유지해야하는 것은 단지 다음 순서의 패킷 순서번호이다.



단점: 그 패킷의 재전송이 손실되거나 왜곡될 수 있으므로 많은 재전송이 필요할 수도있다.

> GBN프로토콜은 순서번호, 누적확인응답, 체크섬, 타임아웃/재전송 동작에 대한 사용이 포함된다.

## 3.4.4 SR
SR프로토콜은 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 풀필요한 재전송을 피한다. 필요에 따라 각각의 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 개별적인 확인 응답을 요구할 것이다. 윈도 크기 N은 파이프라인에서 아직 확인 응답이 안 된 패킷 수를 제한하는 데 사용된다.


SR수신자는 패킷의 순서와는 무관하게 손상없이 수신된 패킷에 대한 확인 응답을 할 것이다. 순서가 바뀐 패킷은 빠진 패킷이 수신될 때까지 버퍼에 저장하고 빠진 패킷이 수신된 시점에서 일련의 패킷을 순서대로 상위 계층에 전달할 수 있다.


SR송신자 이벤트와 행동
1. 상위로부터 데이터 수신
   ~~~
   상위에서 데이터가 수신될 때, SR송신자는 패킷의 다음 순서번호를 검사한다.
   순서번호가 송신자 윈도내에 있으면 데이터는 패킷으로 송신된다. 그렇지 않으면 GBN처럼 버퍼에 나중에 전송하기 위해 돌려진다.
   ~~~
2. 타임아웃
   ~~~
   타이머는 손실된 패킷을 보호하기위해 재사용된다. 그러나 타임아웃 시 오직 한 패킷만이 전송되기 때문에, 각 패킷은 자신의 논리 타이머가 있어야한다. 하나의 타이머가 여러개의 논리 타이머를 흉내내는데 사용된다.
   ~~~
3. ACK수신
   ~~~
   ACK가 수신되었을 때, SR송신자는 그 ACK가 윈도내에 있다면 그 패킷을 수신된 것을 표기한다. 만약 패킷 순서번호가 send_base와 같다면 ,윈도 베이스는 가장 작은 순서 번호를 가진 아직 확인되지않은 패킷으로 옮겨진다. 만약 윈도가 이동하고 윈도 내의 순서 번호를 가진 미전송 패킷이 있다면 이 패킷들은 전송된다.
   ~~~
   


SR수신자 이벤트와 행동
1. [ rcv_base, rcv_base+N-1 ]내의 순서번호를 가진 패킷이 손상없이 수신된다.
   ~~~
   이 경우는 수신된 패킷이 수신자의 윈도에 속하는 것이며, 선택적인 ACK패킷이 송신자에게 회신된다. 만약 이 패킷이 이전에 수신되지 않았던 것이라면 버퍼에 저장된다.
   만약 이 패킷 수신 윈도의 base와 같은 순서번호를 가졌다면, 이 패킷과 이전에 버퍼에 저장되어 연속적으로 번호를 가진 패킷들은 상위계층으로 전달된다.
   ~~~
2. [ rcv_base-N, rcv_base-1 ] 내의 순서 번호를 가진 패킷이 수신된다.
   ~~~
   이 경우에는 이 패킷이 수신자가 이전에 확인응답한 것이라도 ACK가 생성되어야 한다.
   ~~~
3. 그 외의 경우, 패킷을 무시한다.

수신자가 현재의 윈도 base보다 작은 즉정 순서 번호르 가진 이미 수신된 패킷을 무시하지 않고 재확인응답을 하는 것이 중요하다.수신자가 송신자에게 보내는 send_base패킷에 대한 ACk가 없다면, 수신자가 그 패킷을 이미수신 했음이 분명하더라도 결국 송신자는 send_base패킷을 재전송할 것이다. 만약 수신자가 이 패킷에 대한 확인응답을 하지 않는다면, 송신자의 윈도는 결코 앞으로 이동하지 않을 것이다.


이는 송신자와 수신자의 윈도가 항상 같지는 않다는 뜻이다.

최소한의 윈도 크기는 얼마인가? => 윈도 크기는 SR프로토콜에 대한 순서 번호 공간 크기의 절반보다 작거나 같아야 한다.



## 3.5 연결지향형 트랜스포트:TCP
### 3.5.1 TCP연결

TCP연결 애플리케션 프로세스가 데이터를 다름 프로세스에게 보내기 전에 두 프로세스가 서로 핸드셰이크를 먼저 해야하므로 연결지향형이다.

즉 데이터 전송을 보장하는 파라미터들을 각자 설정하귀 위해 어떤 사전 세그먼트들을 보내야한다. TCP연결 설정의 일부로서, 연결의 양단은 TCP연결과 연관된 많은 TCP상태변수를 초기화한다.

TCP연결은 TDM이나 FDM이 아니다. 












